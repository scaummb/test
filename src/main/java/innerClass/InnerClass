【内部类】
内部类继承自某个类或者实现了某个接口。内部类的代码可以操作创建它的外围类的对象。可以说内部类提供了某种进入外部类的窗口。
切中内部类的核心的问题：如果只需要接口引用，为什么不让外部类实现接口？如果这能满足需求，那就应该这样做。
内部类实现接口和外部类实现接口的区别：不是总能拥有接口的便利性，有时需处理实现。
使用内部类最吸引人的原因：每个内部类可以独立的继承自一个接口的实现，无论外围类是否继承了一个实现，对内部类都没有影响
内部类允许继承多个非接口类型。

【分类】
成员内部类：和成员变量一个级别
局部内部类：在方法里的内部类（方法域内生效 或者 方法内某一段代码块域内生效）
匿名内部类：基本上属于接口的实现类，一次性使用的场景。
静态内部类：static修饰的成员内部类。

静态内部类的作用：只是为了降低包的深度，方便类的使用，静态内部类适用于包含类当中，但又不依赖与外在的类，不用使用外在类的非静态属性和方法，只是为了方便管理类结构而定义。在创建静态内部类的时候，不需要外部类对象的引用。

【闭包和回调】
闭包是可调用对象，保留了创建闭包的作用域的信息.(Java匿名内部类是残缺的闭包,匿名内部类来自外部闭包环境的自由变量必须是final的)

内部类是面向对象的闭包，它不仅包含来自外部类对象的每条信息，还自动持有对整个外部类对象的引用，有权操作所有成员，包括私有成员。

java中最引人注意的争议是引入回调这种指针机制。通过回调，对象能够携带一些信息，以允许在稍后的某个时刻调用初始对象

【内部类和控制框架】
设计模式是将变化的部分和不变的部分分离开来。
所以模版方法设计模式中，模版方法是不变的部分，可重写的方法是变的部分。
控制框架：用来解决响应事件的需求。
事件驱动系统：用以响应事件的系统。
命令设计模式：请求封装为对象。


【内部类可以被覆盖么？】
两个内部类是完全独立的实体。各自在自己的命名空间内。


【内部类继承】
内部类构造器必须连接上指向其外围类对象的引用。在继承内部类的时候必须要指明这种关联。

【局部内部类】
使用局部内部类代替匿名内部类的唯一理由就是是否需要有名称的构造器或者重载构造器。匿名内部类只能使用实例初始化。另一个理由就是是否需要不止一个对象。

【内部类标识】
由于每个类都会生成一个**.class文件，持有所有信息，关于如何创建此类型的对象的信息（此信息生成“meta-class”,称为Class**对象）。
内部类class文件命名规则：OuterClassName + ‘$’ + InnerClassName
如果内部类是匿名的，编译器生成数字作为内部类的标识符。如果内部类是嵌入在内部类中，则名称附加在外围类标识符和$之后
