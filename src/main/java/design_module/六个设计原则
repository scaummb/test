2.常用的六大设计原则
1)单一职责原则
2)里氏替换原则
3)依赖倒转原则
4)接口隔离原则
5)迪米特法则
6)开闭原则
单一职责原则（Single Responsibility Principle）；
开闭原则（Open Closed Principle）；
里氏替换原则（Liskov Substitution Principle）；
迪米特法则（Law of Demeter），又叫“最少知道法则”；
接口隔离原则（Interface Segregation Principle）；
依赖倒置原则（Dependence Inversion Principle）。

软件设计最大的难题就是应对需求的变化，但是纷繁复杂的需求变化又是不可预料的，我们要为不可预料的变化做好准备，这本身是一件非常痛苦的事情，但好在有大师们已经给我们提出了非常好的六大设计原则和23种设计模式来“封装”未来的变化。


1、开闭原则(fix)
一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭.
一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。
当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
当我们遵循前面介绍的5大原则，以及使用23中设计模式的目的就是遵循开闭原则。

2、迪米特法则(fix)
一个对象应该对其他对象保持最少的了解。
类与类关系越密切，耦合度越大。
迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息。迪米特法则还有个更简单的定义：只与直接的朋友通信。
迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系
举例子：
总公司高管-》子公司雇员
        -》子公司高管-》子公司雇员
        但是总公司高管提供了一个方法，涉及到了子公司雇员，这是不对的，它不应该管得着子公司雇员。

3、依赖倒置原则（fix）
1）上层模块不应该依赖底层模块，它们都应该依赖于抽象。
2）抽象不应该依赖于细节，细节应该依赖于抽象。
举例子:
类A直接依赖类B，如果要将类A改为依赖类C，则必须通过修改类A的代码来达成。此时，类A一般是高层模块，负责复杂的业务逻辑，类B和类C是低层模块，负责基本的原子操作；修改A会给程序带来风险。
将类A修改未依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或类C发生联系，则会大大降低修改类A的记几率。

4、单一职责原则（fix）
该原则是针对类来说的，即一个类应该只负责一项职责。
举例子：
如类T负责两个不同职责：职责P1，职责P2。当职责P1需求变更而改变T时，可能造成职责P2发生故障，所以需要将类T的粒度分解为T1，T2。

5、里氏替换原则（fix）
所有引用基类的地方必须能透明地使用其子类的对象。
遵循里氏替换原则，在子类中尽量不要重写和重载父类的方法。
继承包含这样一层含义：父类中凡是已经实现好的方法（相对抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。
继承作为面向对象三大特性之一，在给程序设计带来巨大遍历的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。

6、接口隔离原则（fix）
该原则中的接口，是一个泛泛而言的接口，不仅仅指Java中的接口，还包括其中的抽象类。
举例子：
这个图的意思是：类A依赖接口I中的方法1，方法2，方法3，类B是对类A依赖的实现；类C依赖接口I中的方法1，方法4，方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然存在用不到的方法（红色标记所示），但由于实现了接口I，所以也必须要实现这些用不到的方法。

接口中出现的方法，不管对依赖于它的类有没有作用，实现类中都必须去实现这些方法。于是我们将原接口I拆分为三个接口。

说到这里，可能会觉得接口隔离原则和之前的单一职责原则很相似，其实不然。
一，单一职责注重职责，而接口隔离原则注重对接口依赖的隔离；
二，单一职责是约束类，其次是方法，针对的是程序中的实现和细节；
而接口隔离原则约束的是接口，针对的是抽象，程序整体框架的构建。

